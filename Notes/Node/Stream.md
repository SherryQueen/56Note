# Stream

> tags: #Stream #Node

## 基本概念

#### 流是什么

> **有序的数据处理**

- **节约内存** 避免一次加载的数据过大, 通过将数据划分成**有序块, 有序的处理**. (将大任务拆解成多个小任务)
- **提升时效** 无需等待数据加载完成后再进行处理, 可以**边加载边处理**

#### 流有什么用

- 流媒体 等 类似数据量大, 加载完成需要耗费大量时间的场景下.
- 需要对大数据的数据进行复杂处理. 可以借助流将任务拆解,提前执行. 如果遇到错误则提前抛出错误

#### 基本流类型

- **Readable Stream** 可读取数据的流 `fs.createReadableStream()`
- **Writeable Stream** 可读取数据的流 `fs.createWriteableStream()`
- **Duplex** 可读可写的双工流
- **Transfer** Duplex 的一种. 用于读写过程中的数据转换

#### 流的特点

- **事件** 流是 `EventEmitter` 的实例. 对外提供各种事件
- **独立缓冲区** 每个流具有自己的缓冲区
- **字符编码** 会影响 chunk 的内容和大小.
- **highWaterMark(水位线)** 数据的阈值, 当读写的数据达到阈值,流将会停止读写,直到当前的数据被消费. 不会限制写入缓冲区的数据大小
  - 对于普通的流, `highWaterMark` 选项指定字节的总数
  - 对于在对象模式下操作的流, `highWaterMark` 指定对象的总数。

## 可读流(ReadableStream)

| 模式           | 流动(Flow)                                                                                                                                  | 暂停(Paused)                                                                                                      |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 获取数据的方式 | 1. 消费者被动接受数据 <br />2. 生产者自动从系统加载数据                                                                                     | 1. 数据会堆积在缓冲区, 生产者根据水位线控制数据传递到缓冲区 <br /> 2. 消费者通过 `stream.read()` 从缓冲区读取数据 |
| 模式切换       | 1. 可通过监听 `data` 事件. 自动变成流动模式 <br/> 2. `stream.resume()`方法让数据继续流动 <br /> 3. `stream.pipe()` 方式开始发送数据到可写流 | 1. 没有管道目标, 即没有消费者, 调用`stream.pause()` <br /> 2. 如果有管道目标移除管道目标 `stream.unpipe()`        |

- 事件
  - `data`: 流动模式(Flow) 被动消费: 可写流有数据会推送到对应的回调函数. 不处理则数据会丢失 直到 `stream.pause()` 或 数据读取完成
  - `readable` 主动模式 表明事件流有新的动态.
    - 如果有新数据 需要调用 `stream.read()` 来主动消费数据
    - 如果没数据 `system.read()` 返回 `null`
- **数据积压**: 可读流与可写流在内部的缓冲区缓存数据. 如果**消费的速率慢于供给的速率**. 会造成缓冲区数据积压

## 可写流(WriteableStream)

- 接收生产者传来的数据并消费(写入到磁盘)
- 事件:
  - `drain` 若可当前可以继续写入数据时,会触发`drain`事件
    - `steam.write(chunk)`时返回数据: 表明缓冲区数据 >= `highWaterMark`
    - ⚠️ 若缓冲区数据 >= `highWaterMark` 依然可以继续写入数据,直达占满 NodeJs 的缓冲区

## 双工流(DuplexStream)

- 具备可写/可读. 二者互相独立, 具有独立的缓冲区. 读写事件独立发生

## 转换流(TransformStream)

- 具备可写/可读. 共同拥有缓冲区只有当写入之后, 才可读取到对应的数据 通过 `transform()` 进行数据的中转

## 管道|Pipe

- `.pipe` 规定了 上游(ReadableStream) -> 下游(WriteableStream)

  - 可以通过多个流 和 `.pipe` 构成管道链. 让数据按制定好的顺序进行流转与转换
  - 仅提供了数据管理，避免出现读写速度不一致的情况，有效避免数据积压
  - 处理管道链的流的错误非常麻烦
  - 如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。
  - 无法得知管道完整的状态（是否已经结束）

- `.pipeline` 可以统一处理 管道链上的各种错误,并控制开关
  - 提供了数据管理，避免出现读写速度不一致的情况，有效避免数据积压
  - 很容易处理管道链报错
  - 如果可读流在处理期间发送错误，则当前管道链所有流都将关闭，避免内存泄漏。
  - 管道链有自己的运行状态，更容易理解。
