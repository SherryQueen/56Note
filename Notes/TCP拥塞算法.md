# TCP 拥塞算法

> tags: #Book #TCP #拥塞算法 #Congestion-control

## TCP 报文的传输过程

1. 发送方发送`1,2,3,4,5`五个序号的报文。
2. 接收方接收到`1`,则向发送方发送确认号为`2`的确认报文(告诉发送方我需要序号为 2 的报文)
3. 接收方接收到`2`则发送确认号为`3`的报文
4. 因为网络不稳定,`3`号报文还未到达,接收方先收到了`4`号报文,则缓存`4`号报文,并发送确认号为`3`的确认报文
5. 接收方收到了`5`号报文,则缓存`5`号报文,并发送确认号为`3`的确认报文
6. 接收方收到了`3`号报文,因为已收到`4`和`5`的报文并在缓存中.此时返回确认号为`6`的报文

## 背景

- **网络拥塞** 网络中的设备或带宽是有限的。当其中的数据报文数量超过或达到上限,会造成一部分数据报文的丢失或延迟转发
- **拥塞控制** 当网络处于**网络拥塞**的状态时，通过减少向网络中发送数据报文，避免恶性循环。或网络空闲时，提高发送速率，充分利用资源

## 算法内容

- **MSS**: 最大报文段长度.`TCP`双方发送的报文段中，包含的数据部分的最大字节数
- **cwnd**:拥塞窗口, **发送方**维护，单位时间内能发出去的数据报文数量. `TCP`发送但还没有得到确认的报文的序号都在这个区间
- **RTT**:往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间
- **ssthresh**: 慢启动阈值.慢启动阶段: 若 `cwnd` 的大小达到这个值，将转换到拥塞避免模式
- 由于 `TCP` 是一次性将窗口内的所有报文发出，所以所有报文都到达并被确认的时间，约等于一个 `RTT`

![Congestion Control](/Assets/tcp-congestion-control.png)

#### 慢启动

- 目的: **尽快找到当前网络的传输上限**
- 步骤:
  1. 初始化 `cwnd=1MSS`
  2. 发送方接收到一个`ack`报文,则`cwnd=2*cwnd` (指数增长,快速探顶)
  3. 遇到特定状态,状态变化
     3.1. 数据传输超时: `ssthresh=cwnd/2`且`cwnd=1MSS`重新开始慢启动. (即原定的阈值在当前网络下过大,重新进行一次探顶)
     3.2. `cwnd>=ssthresh`.达到阈值,进入**拥塞控制**阶段 (探顶成功后,通过拥塞控制继续探究当前网络可传输上限,但不适合指数增长`cwnd`)
     3.3. 接收到`三次重复的冗余确认` 触发 **快恢复**: `ssthresh=cwnd/2`且`cwnd=ssthresh+3MSS` 进入**拥塞控制**

#### 拥塞控制

- 目的: **缓慢地探顶,因为网络状况会随时变化,上次拥塞的顶不代表当前的顶**
- 步骤:
  1. `cwnd`为上次拥塞控制的一半,即当前的`cwnd`增长很容易触发网络拥塞. 故采取**缓慢的线性增长`cwnd`** 一个`RTT`后`cwnd=cwnd+1MSS`
  2. 遇到特定状态,状态变化
     2.1. 数据传输超时 触发**快重传**: `ssthresh=cwnd/2`且`cwnd=0`重新进入**慢启动**
     2.2. 接收到`三次重复的冗余确认` 触发 **快恢复**: `ssthresh=cwnd/2`且`cwnd=ssthresh+3MSS` 进入**拥塞控制**
